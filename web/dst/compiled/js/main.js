/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./web/src/js/colorTheme.js":
/*!**********************************!*\
  !*** ./web/src/js/colorTheme.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module '/js/js.cookie.min.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n\n\nfunction getTheme() {\n  const theme = Cookies.get('theme');\n\n  if (!theme || theme == 'light') {\n    return 'light';\n  } else {\n    return 'dark';\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getTheme);\n\n//# sourceURL=webpack://web/./web/src/js/colorTheme.js?");

/***/ }),

/***/ "./web/src/js/editor.js":
/*!******************************!*\
  !*** ./web/src/js/editor.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _getApiUrl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getApiUrl */ \"./web/src/js/getApiUrl.js\");\n/* harmony import */ var _colorTheme__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./colorTheme */ \"./web/src/js/colorTheme.js\");\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module '/js/getEnv.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module '/js/urlParameter.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module '/codemirror/lib/codemirror.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module '/js/js.cookie.min.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module '/js/uuidv4.min.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module '/js/memoHelper.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n\n\n\n\n\n\n\n\naxios.defaults.withCredentials = true;\nconst ShareTypes = {\n  DoNotShare: 1,\n  Readonly: 2,\n  Editable: 4\n};\nconst PinnedTypes = {\n  NoPinned: 1,\n  Pinned: 2\n};\n\nclass ViewModes {\n  constructor(mode) {\n    this.modeDescriptions = ['Normal', 'Source', 'Preview'];\n    this.nowMode = mode;\n\n    if (this.nowMode < 0 || this.nowMode >= this.modeDescriptions.length) {\n      this.nowMode = 0;\n    }\n\n    this.ModeList = {\n      Normal: 0,\n      Source: 1,\n      Preview: 2\n    };\n  }\n\n  switchMode() {\n    this.nowMode++;\n\n    if (this.nowMode >= this.modeDescriptions.length) {\n      this.nowMode = 0;\n    }\n  }\n\n  setMode(mode) {\n    this.nowMode = mode;\n\n    if (this.nowMode < 0 || this.nowMode >= this.modeDescriptions.length) {\n      this.nowMode = 0;\n    }\n  }\n\n  get mode() {\n    return this.nowMode;\n  }\n\n  get modeDescription() {\n    this.modeDescription[this.nowMode];\n  }\n\n}\n\nconst tagsComponent = Vue.extend({\n  name: 'tags-component',\n  template: `\n    <div class=\"tags-container\">\n        <tags-select\n            :options=\"allTags\"\n            v-model=\"relatedTags\"\n            label=\"name\"\n            track-by=\"name\"\n            hideSelected=\"true\"\n            :taggable=\"true\"\n            :multiple=\"true\"\n            :max=10\n            :limitText=10\n            tagPlaceholder=\"タグを作成(50文字まで)\"\n            selectLabel=\"\"\n            placeholder=\"\"\n            deselectLabel=\"選択を解除\"\n            @tag=\"createNewTag\"\n            @select=\"setTagRelation\"\n            @remove=\"removeTagRelation\"\n        ></tags-select>\n    </div>\n    `,\n\n  data() {\n    return {\n      allTags: [],\n      relatedTags: [],\n      tagRecommends: []\n    };\n  },\n\n  props: ['memoId'],\n\n  mounted() {},\n\n  methods: {\n    loadTags() {\n      // tagを取得\n      this.getAllTags();\n    },\n\n    getAllTags() {\n      axios.get((0,_getApiUrl__WEBPACK_IMPORTED_MODULE_0__.default)() + '/get_tags').then(res => {\n        console.log(res.data);\n        let tagNameList = [];\n        this.allTags = res.data.tags;\n        res.data.tags.forEach(e => {\n          tagNameList.push(e.name);\n        });\n        this.$set(this, 'tagRecommends', tagNameList); // 成功したら関連付けを取得\n\n        this.getRelationTags();\n      }).catch(err => {\n        console.log(err);\n        this.$parent.errorMessage = 'タグの取得に失敗しました';\n      }).then(() => {});\n    },\n\n    getRelationTags() {\n      // 新規保存時は空の場合がある\n      if (!this.memoId) return;\n      axios.get((0,_getApiUrl__WEBPACK_IMPORTED_MODULE_0__.default)() + '/get_relation_tags', {\n        params: {\n          memo_id: this.memoId\n        }\n      }).then(res => {\n        console.log(res.data);\n        res.data.tags.forEach(e => {\n          const uuid = e.tag_uuid; // 探してくる\n\n          const targetTag = this.allTags.find(e => e.uuid == uuid);\n\n          if (!targetTag) {\n            this.$parent.errorMessage = 'メモと関連付けられたタグの取得に失敗しました';\n            return;\n          }\n\n          const newTagData = {\n            uuid: uuid,\n            name: targetTag.name\n          };\n          this.relatedTags.push(newTagData);\n        });\n      }).catch(err => {\n        console.log(err);\n        this.$parent.errorMessage = 'メモと関連付けられたタグの取得に失敗しました';\n      }).then(() => {});\n    },\n\n    /**\r\n     * 新規にタグを作成する\r\n     * \r\n     * @param {string} newTag 新しいタグ \r\n     */\n    createNewTag(newTag) {\n      console.log(newTag);\n\n      if (newTag.length > 50) {\n        this.$parent.errorMessage = 'タグの名前の長さは50文字までです';\n        return false;\n      }\n\n      axios.post((0,_getApiUrl__WEBPACK_IMPORTED_MODULE_0__.default)() + '/update_tag', {\n        params: {\n          name: newTag\n        }\n      }).then(res => {\n        const newTagData = {\n          uuid: res.data.id,\n          name: newTag\n        };\n        this.allTags.push(newTagData);\n        this.relatedTags.push(newTagData);\n        this.setTagRelation(newTagData);\n      }).catch(err => {\n        console.log(err);\n        this.$parent.errorMessage = 'タグの追加に失敗しました';\n      }).then(() => {});\n    },\n\n    setTagRelation(tag) {\n      console.log(tag); // 10個制限\n\n      if (this.relatedTags.length >= 10) {\n        this.$parent.errorMessage = '1つのメモに対するタグ付けは10個までです';\n        return false;\n      }\n\n      axios.post((0,_getApiUrl__WEBPACK_IMPORTED_MODULE_0__.default)() + '/set_tag_relation', {\n        params: {\n          'tag_uuid': tag.uuid,\n          'memo_uuid': this.memoId\n        }\n      }).then(res => {\n        console.log(res.data);\n      }).catch(err => {\n        console.log(err);\n        this.$parent.errorMessage = 'タグの関連付けに失敗しました';\n      }).then(() => {});\n    },\n\n    removeTagRelation(tag) {\n      axios.post((0,_getApiUrl__WEBPACK_IMPORTED_MODULE_0__.default)() + '/delete_tag_relation', {\n        params: {\n          'tag_uuid': tag.uuid,\n          'memo_uuid': this.memoId\n        }\n      }).then(res => {\n        console.log(res.data);\n      }).catch(err => {\n        console.log(err);\n        this.$parent.errorMessage = 'タグの関連付けの削除に失敗しました';\n      }).then(() => {});\n    }\n\n  }\n});\nVue.component('tags-component', tagsComponent);\nVue.component('tags-select', window.VueMultiselect.default);\nnew Vue({\n  el: '#memoEditor',\n  data: () => {\n    return {\n      errorMessage: '',\n      types: ['plain', 'markdown'],\n      shareTypes: [{\n        id: ShareTypes.DoNotShare,\n        description: 'Do not share'\n      }, {\n        id: ShareTypes.Readonly,\n        description: 'Read only'\n      }, // {id: 3, description: 'Commentable'},\n      {\n        id: ShareTypes.Editable,\n        description: 'Editable'\n      }],\n      shareScopeTypes: [{\n        id: 1,\n        description: 'Public'\n      }, {\n        id: 2,\n        description: 'Specific Users'\n      }],\n      memo: {\n        id: '',\n        // 編集時のみ\n        title: 'No title',\n        description: '',\n        body: '',\n        type: 1,\n        // markdown\n        share: {\n          type: 1,\n          scope: 1,\n          id: '',\n          users: ''\n        }\n      },\n      viewModes: new ViewModes(undefined.ModeList.Normal),\n      updatePreviewTimeout: null,\n      autoSaveTimeout: null,\n      autoSaveDelay: 5000,\n      codemriror: null,\n      codemirrorHelper: null,\n      showMessageTime: 3000,\n      isShowShareDialog: false,\n      isSharedView: false,\n      theme: 'light',\n      memoMessages: [],\n      isSaving: false,\n      saveInterval: 10000\n    };\n  },\n  computed: {\n    shareUrl() {\n      if (!this.memo.share.id) {\n        return '';\n      }\n\n      const domain = document.domain;\n      return 'https://' + domain + '/' + 'memo.html?share_id=' + this.memo.share.id;\n    },\n\n    isReadOnly() {\n      return this.getIsReadOnly();\n    }\n\n  },\n\n  mounted() {\n    // まずテーマ取得\n    this.theme = (0,_colorTheme__WEBPACK_IMPORTED_MODULE_1__.default)(); // codemirrorの適用\n\n    const cm = CodeMirror.fromTextArea(document.getElementById('memoBodyTextarea'), {\n      mode: 'markdown',\n      lineNumber: true,\n      indentUnit: 4,\n      theme: this.theme == 'light' ? 'mdn-like' : 'darcula',\n      lineNumbers: true,\n      autoCloseBrackets: true,\n      scrollbarStyle: \"simple\",\n      keyMap: 'default',\n      inputStyle: 'contenteditable',\n      historyEventDelay: 300,\n      autofocus: true,\n      dragDrop: false,\n      extraKeys: {\n        \"Enter\": \"newlineAndIndentContinueMarkdownList\",\n        \"Ctrl-Enter\": \"newlineAndIndentContinueMarkdownListToUnder\",\n        \"Shift-Ctrl-Enter\": \"newlineAndIndentContinueMarkdownListToAbove\",\n        \"Ctrl-S\": cm => {\n          this.save();\n        },\n        \"Ctrl-Alt-Up\": \"addMultiCursorUp\",\n        \"Ctrl-Alt-Down\": \"addMultiCursorDown\",\n        Tab: function (cm) {\n          var spaces = Array(cm.getOption(\"indentUnit\") + 1).join(\" \");\n          cm.replaceSelection(spaces);\n        }\n      }\n    });\n    this.codemirror = cm; // body変更時の挙動設定\n\n    this.codemirror.on('change', () => {\n      this.memo.body = this.codemirror.getValue();\n      this.updatePreview();\n      if (this.autoSaveTimeout) clearTimeout(this.autoSaveTimeout);\n      this.autoSaveTimeout = setTimeout(this._save, this.autoSaveDelay);\n    });\n    const osName = platform.os.toString();\n\n    if (osName.indexOf('Android') >= 0 || osName.indexOf('iOS') >= 0 || osName.indexOf('Windows Phone') >= 0) {\n      const origOnKeyPress = cm.display.input.onKeyPress; // 元のkeypressを取得\n\n      cm.display.input.onKeyPress = function (e) {\n        // iOSの絵文字キーボードのように、サロゲートペアの直接のkeypressは、CodeMirrorの処理を通すと文字化けるのでキャンセルする\n        if (e.which >= 0x10000) {\n          return;\n        }\n\n        if (!cm.display.input.composing) {\n          // 文字入力中かどうかはcomposingでわかる\n          cm.keyPressTimer = setTimeout(() => {\n            origOnKeyPress.call(this, e);\n          }, 30); // 30ms以内（適当）にcompositionstartが呼ばれなければkeypressは実行して良い\n        }\n      };\n\n      const inputArea = cm.display.input.div || cm.display.input.textarea; // 一応、inputStyleがどちらの状態でも大丈夫な書き方にした\n\n      inputArea.addEventListener('compositionstart', (_cm, e) => {\n        if (cm.keyPressTimer) {\n          clearTimeout(cm.keyPressTimer);\n        }\n      }, false);\n      const inputField = cm.display.input.getField(); // IME入力中のkeydownをCodeMirrorに渡さないようにする\n\n      window.addEventListener('keydown', function (e) {\n        if (e.target == inputField && cm.display.input.composing) {\n          e.stopPropagation();\n        }\n      }, true); // バーチャルキーボードの「完了」ボタンを押した時に、キーボードだけが消えないようにする\n\n      inputField.addEventListener('blur', function (e) {\n        if (e.relatedTarget) {\n          // 「完了」ボタンでのblurかどうか\n          return;\n        }\n\n        e.stopPropagation(); // stopしないと文字が二重で入力される\n\n        if (cm.display.input.composing) {\n          // 再focusが確定したらblurさせる\n          inputField.focus();\n          setTimeout(function () {\n            inputField.blur();\n          }, 1);\n        }\n      }, false);\n    }\n\n    this.codemirrorHelper = new Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '/js/memoHelper.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(this.codemirror); // memo idを取得\n\n    const memoId = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '/js/urlParameter.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())('memo_id');\n    const shareId = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '/js/urlParameter.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())('share_id');\n\n    if (memoId) {\n      this.memo.id = memoId;\n      this.load();\n    } else if (shareId) {\n      this.isSharedView = true;\n      this.loadByShareId(shareId);\n    } else if (!memoId) {\n      // 新規作成なので即保存\n      this.save();\n      this.$refs.tags.loadTags();\n    } // markedの設定\n\n\n    marked.setOptions({\n      langPrefix: '',\n      highlight: function (code, lang) {\n        return hljs.highlightAuto(code, [lang]).value;\n      }\n    });\n  },\n\n  methods: {\n    /**\r\n     * メモを保存する\r\n     */\n    _save() {\n      // シェア画面で編集権限がないとき\n      if (this.isSharedView && this.memo.share.type != 4) {\n        console.log(memo);\n        return;\n      }\n\n      this.errorMessage = '';\n\n      if (this.memo.body.length > this.getMaxBodyLen()) {\n        this.errorMessage = 'メモの上限文字数は' + this.getMaxBodyLen() + '文字です';\n        return;\n      }\n\n      if (this.memo.title.length == 0) {\n        this.errorMessage = 'メモのタイトルは必須です';\n        return;\n      }\n\n      if (this.memo.title.length > 200) {\n        this.errorMessage = 'メモのタイトルの上限文字数は200文字です';\n        return;\n      } // 保存処理\n\n\n      this.isSaving = true;\n      axios.post((0,_getApiUrl__WEBPACK_IMPORTED_MODULE_0__.default)() + '/save_memo', {\n        params: {\n          memo: this.memo,\n          files: this.getFileKeys()\n        }\n      }).then(res => {\n        console.log('save complete: ' + res.data.id);\n        this.memo.id = res.data.id;\n        this.drawMessage('saved');\n      }).catch(err => {\n        console.log(err);\n\n        if (err.response && err.response.data.is_limit_length) {\n          this.errorMessage = 'メモの上限文字数は' + this.getMaxBodyLen() + '文字です';\n        } else {\n          this.errorMessage = 'Failed to update memo.';\n        }\n      }).then(() => {\n        this.isSaving = false;\n      });\n    },\n\n    save() {\n      if (this.getIsReadOnly()) return;\n      if (this.autoSaveTimeout) clearTimeout(this.autoSaveTimeout);\n\n      this._save();\n    },\n\n    getMaxBodyLen() {\n      if (!window.userData) {\n        return 10000000;\n      }\n\n      const userData = window.userData;\n\n      if (!userData) {\n        return 10000;\n      } else if (userData.plan == 1) {\n        return 10000;\n      } else if (userData.plan >= 1000) {\n        return 100000;\n      } else {\n        return 10000;\n      }\n    },\n\n    getFileKeys() {\n      let r = /a/;\n\n      switch (Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '/js/getEnv.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())()) {\n        case 'dev':\n          r = /https:\\/\\/fileapi\\.dev-md-memo\\.tori-blog\\.net\\/get_file\\/\\?file_key=([\\w_\\-%]+)/g;\n          break;\n\n        case 'stg':\n          r = /https:\\/\\/fileapi\\.stg-md-memo\\.tori-blog\\.net\\/get_file\\/\\?file_key=([\\w_\\-%]+)/g;\n          break;\n\n        case 'prod':\n          r = /https:\\/\\/fileapi\\.memo-ease\\.com\\/get_file\\/\\?file_key=([\\w_\\-%]+)/g;\n          break;\n\n        default:\n          r = /https:\\/\\/fileapi\\.memo-ease\\.com\\/get_file\\/\\?file_key=([\\w_\\-%]+)/g;\n          break;\n      }\n\n      let m = null;\n      var a = [];\n\n      while ((m = r.exec(this.memo.body)) != null) {\n        a.push(m[1]);\n      }\n\n      console.log(a);\n      return a;\n    },\n\n    setMemoData(memo) {\n      let newMemoData = {};\n      newMemoData.id = memo.uuid;\n      newMemoData.title = memo.title;\n      newMemoData.description = memo.description;\n      newMemoData.type = memo.memo_type;\n      newMemoData.body = memo.body;\n      newMemoData.share = {\n        type: 1,\n        scope: 1,\n        id: '',\n        users: ''\n      };\n\n      if (memo.share) {\n        newMemoData.share.id = memo.share.share_id;\n        newMemoData.share.type = memo.share.share_type;\n        newMemoData.share.scope = memo.share.share_scope;\n        newMemoData.share.users = memo.share.share_users;\n      }\n\n      if (!memo.pinned_type) {\n        newMemoData.pinnedType;\n      } else {\n        newMemoData.pinnedType = memo.pinned_type;\n      }\n\n      if (memo.is_trash) {\n        newMemoData.isTrash = true;\n        this.viewModes.setMode(this.ModeList.Preview);\n      }\n\n      this.$set(this, 'memo', newMemoData);\n      this.codemirror.setValue(this.memo.body);\n      this.updatePreviewCallback();\n    },\n\n    getIsReadOnly() {\n      return !(!this.isSharedView || this.memo.share && this.memo.share.type == 4) || this.memo.isTrash;\n    },\n\n    /**\r\n     * メモとタグを読み込む\r\n     */\n    load() {\n      if (this.memo.id) {\n        axios.get((0,_getApiUrl__WEBPACK_IMPORTED_MODULE_0__.default)() + '/get_memo_data', {\n          params: {\n            memo_id: this.memo.id\n          }\n        }).then(res => {\n          console.log(res.data);\n          this.setMemoData(res.data.memo);\n        }).catch(err => {\n          console.log(err);\n          this.errorMessage = 'Failed to load memo data.';\n        }).then(() => {});\n      } // タグを読み込む\n\n\n      this.$refs.tags.loadTags();\n    },\n\n    loadByShareId(shareId) {\n      if (shareId) {\n        axios.get((0,_getApiUrl__WEBPACK_IMPORTED_MODULE_0__.default)() + '/get_memo_data_by_share_id', {\n          params: {\n            share_id: shareId\n          }\n        }).then(res => {\n          console.log(res.data);\n          this.setMemoData(res.data.memo); // リードオンリーの場合はプレビュー表示が初期状態\n\n          if (this.memo.share.type == ShareTypes.Readonly) {\n            this.viewModes.setMode(this.ModeList.Preview);\n          }\n        }).catch(err => {\n          console.log(err);\n          this.errorMessage = 'Failed to load memo data.';\n        }).then(() => {});\n      }\n    },\n\n    /**\r\n     * markdownのプレビューを更新する\r\n     */\n    updatePreview() {\n      if (this.updatePreviewTimeout) {\n        clearTimeout(this.updatePreviewTimeout);\n      }\n\n      this.updatePreviewTimeout = setTimeout(this.updatePreviewCallback, 300);\n    },\n\n    /**\r\n     * 通常はupdatePreviewが呼び出す. 即時実行されるため, そのときに呼んでも良い\r\n     * TODO: rename refactoring\r\n     */\n    updatePreviewCallback() {\n      document.getElementById('memoBodyPreview').innerHTML = marked(this.memo.body);\n      this.updatePreviewTimeout = null;\n    },\n\n    /**\r\n     * メモ画面にメッセージを表示する\r\n     * \r\n     * @param {string} message 表示するメッセージ \r\n     */\n    drawMessage(message) {\n      console.log('draw message: ' + message);\n      const uuid = uuidv4();\n      this.memoMessages.push({\n        uuid: uuid,\n        message: message\n      });\n      setTimeout(() => {\n        this.deleteMessage(uuid);\n      }, this.showMessageTime);\n    },\n\n    /**\r\n     * メッセージを削除する\r\n     * \r\n     * @param {string} uuid 削除するメッセージのuuid \r\n     */\n    deleteMessage(uuid) {\n      const delIdx = this.memoMessages.findIndex(e => e.uuid == uuid);\n\n      if (delIdx >= 0) {\n        this.memoMessages.splice(delIdx, 1);\n      }\n    },\n\n    /**\r\n     * シェア機能のダイアログ表示\r\n     */\n    showShareDialog() {\n      this.isShowShareDialog = true;\n    },\n\n    closeDialog() {\n      this.isShowShareDialog = false;\n    },\n\n    /**\r\n     * 共有リンクをクリップボードにコピー\r\n     */\n    copyShareUrl() {\n      var copyText = document.querySelector(\"#shareLink\");\n      copyText.select();\n      document.execCommand(\"copy\");\n    },\n\n    /**\r\n     * 共有リンクを現在の設定で更新する\r\n     */\n    updateShareLink() {\n      axios.post((0,_getApiUrl__WEBPACK_IMPORTED_MODULE_0__.default)() + '/update_share_settings', {\n        params: {\n          id: this.memo.id,\n          share: this.memo.share\n        }\n      }).then(res => {\n        this.memo.share.id = res.data.share_id;\n        console.log(res);\n      }).catch(err => {\n        this.errorMessage = 'シェア設定の変更に失敗しました';\n        console.log(err);\n      }).then(() => {});\n      return false;\n    },\n\n    switchViewMode() {\n      this.viewModes.switchMode();\n    },\n\n    switchPinned() {\n      axios.post((0,_getApiUrl__WEBPACK_IMPORTED_MODULE_0__.default)() + '/switch_pinned', {\n        params: {\n          id: this.memo.id\n        }\n      }).then(res => {\n        console.log(res.data);\n        this.$set(this.memo, 'pinnedType', res.data.pinned_type);\n        console.log(this.memo.pinnedType == 2);\n      }).catch(err => {\n        this.errorMessage = 'ピン留め設定の変更に失敗しました';\n        console.log(err);\n      }).then(() => {});\n      return false;\n    },\n\n    createUploadTmpKey() {\n      const LENGTH = 8; //生成したい文字列の長さ\n\n      const SOURCE = \"abcdefghijklmnopqrstuvwxyz0123456789\"; //元になる文字\n\n      let result = '';\n\n      for (let i = 0; i < LENGTH; i++) {\n        result += SOURCE[Math.floor(Math.random() * SOURCE.length)];\n      }\n\n      return result;\n    },\n\n    uploadFileBySignedUrl(file, url, key, tmpKey) {\n      var reader = new FileReader();\n      reader.readAsArrayBuffer(file);\n\n      reader.onload = () => {\n        axios({\n          method: 'PUT',\n          url: url,\n          headers: {\n            'Content-Type': file.type\n          },\n          data: reader.result\n        }).then(res => {\n          console.log(res);\n        }).catch(err => {\n          console.log(err);\n          this.errorMessage = 'アップロードに失敗しました';\n          this.invokeCodemirrorOperation('uploadFailed', tmpKey);\n        }).then(() => {});\n      };\n    },\n\n    uploadFile(e) {\n      let files = [...e.dataTransfer.files];\n\n      if (files.length == 0) {\n        return;\n      }\n\n      files.forEach(file => {\n        let tmpKey = file.name.replace(/[\\[\\]\\!]/g, '_'); // アップロード中の文字列を追加\n\n        this.invokeCodemirrorOperation('uploadFile', tmpKey);\n\n        if (file.size > 1024 * 1024 * 8) {\n          this.errorMessage = '8MBまでアップロード可能です';\n          return false;\n        } // 署名付きURLを取得し, 成功したらそこにアップロード\n\n\n        axios.post((0,_getApiUrl__WEBPACK_IMPORTED_MODULE_0__.default)() + '/create_upload_url', {\n          params: {\n            fileName: file.name,\n            fileSize: file.size\n          }\n        }).then(res => {\n          console.log(res);\n          const key = res.data.key;\n          const url = res.data.url;\n          console.log('upload url: ' + key); // アップ完了の文字置換\n\n          this.invokeCodemirrorOperation('uploadComplete', tmpKey, key); // 反映のため, 即保存\n\n          this.save(); // 画像本体アップ\n\n          this.uploadFileBySignedUrl(file, url, key, tmpKey);\n        }).catch(err => {\n          console.log(err);\n          this.errorMessage = 'アップロード用URLの取得に失敗しました';\n          this.invokeCodemirrorOperation('uploadFailed', tmpKey);\n        }).then(() => {});\n      });\n    },\n\n    invokeCodemirrorOperation(op, ...args) {\n      return this.codemirrorHelper.invoke(op, ...args);\n    }\n\n  }\n});\n\n//# sourceURL=webpack://web/./web/src/js/editor.js?");

/***/ }),

/***/ "./web/src/js/getApiUrl.js":
/*!*********************************!*\
  !*** ./web/src/js/getApiUrl.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {\n  return 'https://' + 'api.' + document.domain;\n}\n\n//# sourceURL=webpack://web/./web/src/js/getApiUrl.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./web/src/js/editor.js");
/******/ 	
/******/ })()
;